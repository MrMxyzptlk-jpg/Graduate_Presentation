<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Espectros de Absorción Óptica y de Rayos X</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Urbanist:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>

    <style>
        /* --- GLOBAL COLOR PALETTE --- */
        :root {
            --bg-main: #000000;
            --bg-card: #050505;
            --bg-overlay: rgba(255, 255, 255, 0.03);
            --text-primary: #f5f5f5;
            --text-secondary: #daffde;
            --text-white: #ffffff;
            --accent-main: #deff9a;
            --accent-purple: #9742f1;
            --accent-green-bright: #6de744;
            --border-dim: rgba(255, 255, 255, 0.1);
            --border-accent: rgba(222, 255, 154, 0.1);
            --shadow-glow: rgba(222, 255, 254, 0.05);
        }

        /* --- CORE STYLES --- */
        * { box-sizing: border-box; }
        body {
            background-color: var(--bg-main); margin: 0; padding: 0;
            height: 100vh; width: 100vw; overflow: hidden;
            font-family: 'Urbanist', sans-serif; color: var(--text-primary);
        }

        #presentation-container { position: relative; width: 100%; height: 100%; }

        .slide {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0; visibility: hidden; transition: opacity 0.5s ease-in-out;
            display: flex; justify-content: center; align-items: center; z-index: 1;
        }

        .slide.active { opacity: 1; visibility: visible; z-index: 2; }

        .slide-content {
            background-color: var(--bg-card); width: 90%; max-width: 1400px; height: 85%;
            border-radius: 12px; padding: 50px 70px; position: relative;
            box-shadow: 0 0 50px var(--shadow-glow);
            border: 1px solid var(--border-dim);
            display: flex; flex-direction: column;
        }
        
        /* TEXT HIGHLIGHTING LOGIC */
        .step-text { color: var(--text-white); opacity: 0.3; transition: all 0.5s ease; }
        .step-text.active { color: var(--accent-main); opacity: 1; text-shadow: 0 0 15px rgba(222, 255, 154, 0.4); }

        /* LAYERS */
        .slide-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            padding: 50px 70px; display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.6s ease, transform 0.6s ease; opacity: 1; transform: scale(1); background-color: var(--bg-card); z-index: 10;
        }
        .slide-layer.hidden { opacity: 0; pointer-events: none; transform: scale(0.95); z-index: 0; }

        /* PLOT STYLES */
        .plot-container { display: flex; justify-content: center; align-items: flex-start; gap: 20px; margin-top: 10px; width: 100%; }
        .plot-box { background: #fff; border: 2px solid #ccc; width: 250px; height: 180px; position: relative; display: flex; justify-content: center; align-items: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .plot-label { margin-top: 10px; color: var(--text-secondary); font-size: 1.2rem; font-weight: bold; text-align: center; }
        .plot-group { display: flex; flex-direction: column; align-items: center; opacity: 0; transform: translateY(20px); transition: all 0.5s ease; }
        .plot-visible { opacity: 1; transform: translateY(0); }

        /* TYPOGRAPHY & LAYOUTS */
        h1 { font-size: 3.5rem; margin: 0 0 20px 0; line-height: 1.1; }
        h2 { font-size: 2.5rem; margin: 0 0 30px 0; color: var(--text-white); font-weight: 400; }
        h3 { font-size: 1.8rem; margin: 0 0 15px 0; color: var(--accent-main); }
        p, li { font-size: 1.4rem; color: var(--text-secondary); line-height: 1.6; }
        span.highlight { color: var(--accent-main); }
        
        .two-column { display: grid; grid-template-columns: 1fr 1fr; gap: 60px; height: 100%; align-items: center; }
        .grid-3 { display: grid; grid-template-columns: repeat(3, 1fr); gap: 30px; margin-top: 30px; }
        .tile { background: var(--bg-overlay); padding: 30px; border-radius: 12px; border: 1px solid var(--border-accent); }
        .tile i { font-size: 2rem; color: var(--accent-main); margin-bottom: 15px; }
        .math-block { background: rgba(255,255,255,0.05); padding: 20px; border-radius: 8px; margin: 20px 0; text-align: center; font-size: 1.3rem; }
        
        .media-container {
            width: 100%; height: 100%; min-height: 400px;
            background: var(--bg-main); border-radius: 12px; overflow: hidden;
            display: flex; justify-content: center; align-items: center; border: 1px solid rgba(222,255,154,0.3);
        }
        .media-container img { max-width: 100%; max-height: 100%; object-fit: contain; }
        
        /* CANVAS */
        .anim-wrapper { position: relative; width: 100%; height: 100%; background: radial-gradient(circle, #222 0%, #000 100%); }
        canvas { display: block; width: 100%; height: 100%; }
        .anim-btn-replay { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 8px 20px; background: transparent; border: 1px solid var(--accent-main); color: var(--accent-main); border-radius: 20px; cursor: pointer; }

        /* CONTROLS */
        .controls-overlay { position: fixed; bottom: 20px; right: 20px; z-index: 100; display: flex; gap: 10px; opacity: 0.3; transition: opacity 0.3s; }
        .controls-overlay:hover { opacity: 1; }
        .nav-btn { background: var(--border-dim); border: 1px solid rgba(255, 255, 255, 0.2); color: #fff; padding: 10px 15px; border-radius: 6px; cursor: pointer; }
        .progress-bar { position: fixed; bottom: 0; left: 0; height: 4px; background: var(--accent-main); width: 0%; transition: width 0.3s; z-index: 101; }
        .slide-footer { position: absolute; bottom: 20px; left: 70px; right: 70px; border-top: 1px solid var(--border-dim); padding-top: 15px; display: flex; justify-content: space-between; opacity: 0.5; font-size: 0.9rem; }
    </style>
</head>
<body>

<div id="presentation-container">

    <!-- SLIDE 1: TITLE -->
    <div class="slide active" id="slide1">
        <div class="slide-content">
            <!-- TITLE LAYER -->
            <div class="slide-layer" id="layer-title">
                <div style="text-align: center;">
                    <h1 style="font-size: 3rem; line-height: 1.4;">
                        <span class="step-text" id="step-0">Determinación</span> de los<br>
                        <span class="step-text" id="step-1">espectros de absorción óptica y de rayos X</span><br>
                        en <span class="step-text" id="step-5">semiconductores y aislantes</span><br>
                        mediante un tratamiento <span class="step-text" id="step-7">ab initio</span><br>
                        <span class="step-text" id="step-8">all-electron incluyendo efectos de muchos cuerpos</span>
                    </h1>
                    <div style="margin-top: 60px; border-top: 2px solid var(--accent-main); padding-top: 30px; display: inline-block;">
                        <p style="font-size: 1.8rem; color: var(--text-white); margin: 0;">Jerónimo Noé Acito Pino</p>
                        <p style="opacity: 0.7; margin: 10px 0 0 0;">Universidad Nacional de Córdoba | FAMAF</p>
                    </div>
                </div>
            </div>
            
            <!-- WORKFLOW LAYER (EXPERIMENTAL SETUP ANIMATION) -->
            <div class="slide-layer hidden" id="layer-workflow">
                <h2 style="margin-bottom: 20px;">Setup Experimental</h2>
                
                <!-- EXPERIMENTAL CANVAS -->
                <div style="width: 100%; height: 200px; margin-bottom: 30px; position: relative; border-bottom: 1px solid var(--border-dim);">
                    <canvas id="experimentCanvas"></canvas>
                </div>

                <!-- PLOTS ROW -->
                <div class="plot-container">
                    <div id="plot-group-1" class="plot-group">
                        <div class="plot-box"><img src="incident.png" style="width:100%; height:100%; padding: 5px; object-fit: contain;"></div>
                        <div class="plot-label">Incidencia \(I_0\)</div>
                    </div>
                    
                    <div id="plot-group-2" class="plot-group">
                        <div class="plot-box"><img src="transmited.png" style="width:100%; height:100%; padding: 5px; object-fit: contain;"></div>
                        <div class="plot-label">Transmisión \(I_t\)</div>
                    </div>
                    
                    <div id="plot-group-3" class="plot-group">
                        <div class="plot-box"><img src="absorbed.png" style="width:100%; height:100%; padding: 5px; object-fit: contain;"></div>
                        <div class="plot-label" style="color: var(--accent-green-bright);">Absorción \(\mu\)</div>
                    </div>
                </div>
            </div>

            <!-- STATIC BANDS LAYER -->
            <div class="slide-layer hidden" id="layer-static-bands">
                <h2>Estructura de Bandas <span class="highlight">Parabólica</span></h2>
                <div class="media-container" style="background: var(--bg-overlay); border: 1px solid var(--border-accent); width: 80%; height: 60%;"><canvas id="staticBandsCanvas"></canvas></div>
                <p style="margin-top: 20px;">Representación del Gap Directo y transiciones ópticas verticales.</p>
            </div>
        </div>
    </div>

    <!-- SLIDE 2: CONTEXT -->
    <div class="slide" id="slide-mb-dft">
        <div class="slide-content">
            <h2>El Desafío: <span class="highlight">Más allá del Estado Base</span></h2>
            <div class="two-column">
                <div>
                    <p>La Teoría del Funcional de la Densidad (DFT) es el estándar para propiedades del estado base, pero falla en estados excitados.</p>
                    <ul>
                        <li><strong>Subestimación del Gap:</strong> Los funcionales estándar (LDA/GGA) subestiman severamente las brechas de banda.</li>
                        <li><strong>Excitaciones Neutras:</strong> La absorción óptica crea pares electrón-hueco (excitones).</li>
                    </ul>
                </div>
                <div class="media-container" style="background: var(--bg-overlay); border: 1px solid var(--border-accent);"><canvas id="mbDftCanvas"></canvas></div>
            </div>
            <div class="slide-footer"><span>Motivación</span><span>2 / 12</span></div>
        </div>
    </div>

    <!-- SLIDE 2.5: GREEN'S FUNCTION CONCEPT -->
    <div class="slide" id="slide-green-prop">
        <div class="slide-content">
            <h2>La Función de Green <span class="highlight">\(G(r, r', t, t')\)</span></h2>
            <p style="text-align:center; opacity: 0.8; margin-bottom: 30px;">Describe la propagación de una partícula o un hueco a través del sistema.</p>
            <div class="two-column">
                <div style="text-align: center; height: 100%; display: flex; flex-direction: column;">
                    <h3 style="color: var(--accent-main);">Propagación de Electrón (\(G^>\))</h3>
                    <div class="media-container" style="flex: 1; border: 1px solid var(--accent-main); position: relative;">
                        <canvas id="greenElectronCanvas"></canvas>
                        <div style="position: absolute; bottom: 10px; width: 100%; text-align: center; color: #fff; font-size: 14px;">Tiempo \(t \rightarrow t'\)</div>
                    </div>
                    <p style="font-size: 1.2rem; margin-top: 10px;">Creación en \(t\), propagación, aniquilación en \(t'\)</p>
                </div>
                <div style="text-align: center; height: 100%; display: flex; flex-direction: column;">
                    <h3 style="color: var(--accent-purple);">Propagación de Hueco (\(G^<\))</h3>
                    <div class="media-container" style="flex: 1; border: 1px solid var(--accent-purple); position: relative;">
                        <canvas id="greenHoleCanvas"></canvas>
                        <div style="position: absolute; bottom: 10px; width: 100%; text-align: center; color: #fff; font-size: 14px;">Tiempo \(t \leftarrow t'\)</div>
                    </div>
                    <p style="font-size: 1.2rem; margin-top: 10px;">Creación en \(t'\), propagación "atrás", aniquilación en \(t\)</p>
                </div>
            </div>
            <div class="slide-footer"><span>Concepto de Propagador</span><span>2.5 / 12</span></div>
        </div>
    </div>

    <!-- SLIDE 3: WORKFLOW -->
    <div class="slide">
        <div class="slide-content">
            <h2>Marco Teórico</h2>
            <div class="grid-3">
                <div class="tile"><i class="fa-solid fa-cube"></i><h3>1. DFT</h3><p>Resuelve las ecuaciones de Kohn-Sham para obtener funciones de onda (\(\phi\)) y energías (\(\epsilon\)).</p></div>
                <div class="tile"><i class="fa-solid fa-arrows-to-circle"></i><h3>2. Aprox. GW</h3><p>Calcula energías de Cuasipartícula. Corrige el gap de banda mediante la autoenergía.</p></div>
                <div class="tile"><i class="fa-solid fa-atom"></i><h3>3. BSE</h3><p>Resuelve la Ecuación de Bethe-Salpeter para la función de Green de dos partículas (e-h).</p></div>
            </div>
            <div class="slide-footer"><span>Metodología</span><span>3 / 12</span></div>
        </div>
    </div>

    <!-- SLIDE 3.5: GW SCREENING -->
    <div class="slide" id="slide-gw-concept">
        <div class="slide-content">
            <h2>Apantallamiento y <span class="highlight">La Aproximación GW</span></h2>
            <div class="two-column">
                <div>
                    <p>La autoenergía \(\Sigma\) se aproxima como el producto de la Función de Green \(G\) y la Interacción Coulombiana Apantallada \(W\).</p>
                    <div class="math-block">\( \Sigma = i G W \)</div>
                    <ul style="font-size: 1.2rem; margin-top: 20px;">
                        <li><strong>\(V\):</strong> Interacción Coulombiana "desnuda" (muy fuerte).</li>
                        <li><strong>\(W = \epsilon^{-1}V\):</strong> Polarización del medio.</li>
                    </ul>
                    <p style="font-size: 1rem; color: #999; margin-top: 40px;"><i class="fa-solid fa-arrow-pointer"></i> Mueva el mouse sobre las cajas para interactuar.</p>
                </div>
                <div style="display: flex; flex-direction: column; gap: 20px; height: 100%;">
                    <div class="media-container" style="flex: 1; position: relative; background: var(--bg-overlay); border: 1px solid var(--border-accent);">
                        <div style="position: absolute; top: 10px; left: 10px; color: var(--text-secondary); font-size: 14px; font-weight: bold; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 4px;">Extra Electrón (Repulsión)</div>
                        <canvas id="screenElectronCanvas"></canvas>
                    </div>
                    <div class="media-container" style="flex: 1; position: relative; background: var(--bg-overlay); border: 1px solid var(--border-accent);">
                        <div style="position: absolute; top: 10px; left: 10px; color: var(--text-secondary); font-size: 14px; font-weight: bold; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 4px;">Extra Hueco (Atracción)</div>
                        <canvas id="screenHoleCanvas"></canvas>
                    </div>
                </div>
            </div>
            <div class="slide-footer"><span>Apantallamiento (Screening)</span><span>3.5 / 12</span></div>
        </div>
    </div>

    <!-- SLIDE 4: ANIMATION (PARABOLIC) -->
    <div class="slide" id="slide-animation">
        <div class="slide-content">
            <h2>La Ecuación de <span class="highlight">Bethe-Salpeter</span></h2>
            <div class="two-column" style="grid-template-columns: 40% 60%;">
                <div>
                    <p>Para describir excitaciones neutras, debemos tratar el electrón y el hueco como un par acoplado.</p>
                    <div class="math-block">\( (E_{ck} - E_{vk})A_{vck} + \Sigma \langle K \rangle A = \Omega A \)</div>
                </div>
                <div class="media-container"><div class="anim-wrapper"><canvas id="excitationCanvas"></canvas><button class="anim-btn-replay" onclick="resetAnim()">Repetir</button></div></div>
            </div>
            <div class="slide-footer"><span>Visualización de Excitones</span><span>4 / 12</span></div>
        </div>
    </div>
    
    <!-- SLIDE 5: CONCLUSIONS -->
    <div class="slide">
        <div class="slide-content" style="text-align: center; justify-content: center;">
            <h2>Conclusiones</h2>
            <ul style="text-align: left; width: 60%; margin: 0 auto;">
                <li>Metodología Validada: All-Electron DFT + G₀W₀ + BSE funciona robustamente.</li>
                <li>Excitones Clave: Explican las características pre-borde.</li>
                <li>Diversidad Material: Escala desde LiF hasta ZnO.</li>
            </ul>
        </div>
    </div>

</div>

<!-- CONTROLS -->
<div class="controls-overlay">
    <button class="nav-btn" onclick="prevSlide()"><i class="fa-solid fa-chevron-left"></i></button>
    <button class="nav-btn" onclick="nextSlide()"><i class="fa-solid fa-chevron-right"></i></button>
    <button class="nav-btn" onclick="toggleFullScreen()"><i class="fa-solid fa-expand"></i></button>
</div>
<div class="progress-bar" id="progressBar"></div>

<script>
    /* --- JAVASCRIPT COLOR PALETTE --- */
    const PALETTE = {
        accent: '#deff9a',       
        photon: '#ffffaa',       
        electron: '#4d4dff',     
        ion: '#ff4d4d',          
        textWhite: '#ffffff',    
        textSecondary: '#daffde',
        interaction: 'rgba(77, 77, 255, 0.8)',
        bgElectron: '#4d4dff',
        purple: '#9742f1' 
    };

    /* --- SCENE MANAGER LOGIC --- */
    let currentSlide = 0;
    let slide1Step = -1; 
    const slides = document.querySelectorAll('.slide');
    const progressBar = document.getElementById('progressBar');

    let anims = { mbDft: null, excitation: null, screenE: null, screenH: null, greenE: null, greenH: null, expSetup: null };
    const screeningMouse = { e: {x:-1000, y:-1000}, h: {x:-1000, y:-1000} };

    function initGlobalListeners() {
        const c1 = document.getElementById('screenElectronCanvas');
        if(c1) {
            c1.parentElement.addEventListener('mousemove', (e) => {
                const rect = c1.getBoundingClientRect();
                screeningMouse.e.x = e.clientX - rect.left; screeningMouse.e.y = e.clientY - rect.top;
            });
            c1.parentElement.addEventListener('mouseleave', () => { screeningMouse.e.x = -1000; });
        }
        const c2 = document.getElementById('screenHoleCanvas');
        if(c2) {
            c2.parentElement.addEventListener('mousemove', (e) => {
                const rect = c2.getBoundingClientRect();
                screeningMouse.h.x = e.clientX - rect.left; screeningMouse.h.y = e.clientY - rect.top;
            });
            c2.parentElement.addEventListener('mouseleave', () => { screeningMouse.h.x = -1000; });
        }
    }
    initGlobalListeners();

    function showSlide(index) {
        if (index < 0) index = 0;
        if (index >= slides.length) index = slides.length - 1;
        
        slides.forEach(slide => slide.classList.remove('active'));
        slides[index].classList.add('active');
        currentSlide = index;
        updateProgress();
        
        Object.keys(anims).forEach(k => { if(anims[k]) cancelAnimationFrame(anims[k]); anims[k]=null; });

        if (slides[index].id === 'slide1') {
            // Check if we are in the workflow state to restart that animation if needed
            if(slide1Step >= 2 && slide1Step <= 4) initExpSetupAnim();
        }
        else if (slides[index].id === 'slide-mb-dft') initMbDftAnim();
        else if (slides[index].id === 'slide-green-prop') initGreensAnim();
        else if (slides[index].id === 'slide-animation') resizeExcitation();
        else if (slides[index].id === 'slide-gw-concept') {
            initScreeningBox('screenElectronCanvas', 'electron');
            initScreeningBox('screenHoleCanvas', 'hole');
        }
    }

    /* --- ROBUST STATE MACHINE (Slide 1) --- */
    function updateSlide1State(step) {
        const titleLayer = document.getElementById('layer-title');
        const workLayer = document.getElementById('layer-workflow');
        const bandsLayer = document.getElementById('layer-static-bands');
        const steps = document.querySelectorAll('.step-text');
        
        steps.forEach(s => s.classList.remove('active'));
        titleLayer.classList.add('hidden');
        workLayer.classList.add('hidden');
        bandsLayer.classList.add('hidden');

        // Animation Handling for Slide 1
        if(anims.expSetup) { cancelAnimationFrame(anims.expSetup); anims.expSetup = null; }

        if (step >= 2 && step <= 4) {
            workLayer.classList.remove('hidden');
            initExpSetupAnim(); // Start Experimental Animation
        } else if (step === 6) { 
            bandsLayer.classList.remove('hidden'); 
            drawStaticBands(); 
        } else { 
            titleLayer.classList.remove('hidden'); 
        }

        const p1 = document.getElementById('plot-group-1');
        const p2 = document.getElementById('plot-group-2');
        const p3 = document.getElementById('plot-group-3');
        const plots = [p1, p2, p3];
        plots.forEach(p => { p.classList.remove('plot-visible'); });

        if (step === 0) document.getElementById('step-0').classList.add('active');
        else if (step === 1) document.getElementById('step-1').classList.add('active');
        else if (step === 2) { p1.classList.add('plot-visible'); }
        else if (step === 3) { p1.classList.add('plot-visible'); p2.classList.add('plot-visible'); } 
        else if (step === 4) { plots.forEach(p => { p.classList.add('plot-visible'); }); }
        else if (step === 5) document.getElementById('step-5').classList.add('active');
        else if (step === 7) document.getElementById('step-7').classList.add('active');
        else if (step === 8) document.getElementById('step-8').classList.add('active');
    }

    function nextSlide() { 
        if (currentSlide === 0) {
            if (slide1Step < 8) { slide1Step++; updateSlide1State(slide1Step); } 
            else { showSlide(currentSlide + 1); }
        } else { showSlide(currentSlide + 1); }
    }

    function prevSlide() {
        if (currentSlide === 0) {
            if (slide1Step > -1) { slide1Step--; updateSlide1State(slide1Step); }
        } else { showSlide(currentSlide - 1); }
    }

    function updateProgress() {
        const progress = ((currentSlide + 1) / slides.length) * 100;
        progressBar.style.width = `${progress}%`;
    }

    function toggleFullScreen() {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen();
        else if (document.exitFullscreen) document.exitFullscreen();
    }

    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowRight' || e.key === ' ') nextSlide();
        if (e.key === 'ArrowLeft') prevSlide();
        if (e.key === 'f') toggleFullScreen();
    });

    /* --- NEW: EXPERIMENTAL SETUP ANIMATION (Slide 1) --- */
    function initExpSetupAnim() {
        const canvas = document.getElementById("experimentCanvas");
        const ctx = canvas.getContext("2d");
        const container = canvas.parentElement;
        
        let width, height;
        let time = 0;

        function animate() {
            if (canvas.width !== container.clientWidth) {
                canvas.width = container.clientWidth; canvas.height = container.clientHeight;
            }
            width = canvas.width; height = canvas.height;
            const centerY = height/2;

            ctx.clearRect(0,0,width,height);

            // 1. Light Source (Beam) - Incident
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width * 0.35, centerY); // To Sample
            ctx.strokeStyle = PALETTE.photon; ctx.lineWidth = 6; ctx.stroke();
            
            // Flowing effect
            ctx.setLineDash([10, 10]); ctx.lineDashOffset = -time; ctx.stroke(); ctx.setLineDash([]);

            // 2. Sample (The Material)
            const sampleX = width * 0.35; const sampleW = width * 0.1;
            ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
            ctx.fillRect(sampleX, centerY - 40, sampleW, 80);
            ctx.strokeStyle = PALETTE.textSecondary; ctx.lineWidth = 2;
            ctx.strokeRect(sampleX, centerY - 40, sampleW, 80);
            ctx.fillStyle = PALETTE.textSecondary; ctx.font="12px Urbanist"; ctx.textAlign="center";
            ctx.fillText("Muestra", sampleX + sampleW/2, centerY - 50);

            // 3. Transmitted Beam (Dimmer)
            ctx.beginPath();
            ctx.moveTo(sampleX + sampleW, centerY);
            ctx.lineTo(width * 0.8, centerY); // To Detector
            ctx.strokeStyle = "rgba(255, 255, 170, 0.4)"; // Dimmer yellow
            ctx.lineWidth = 6; ctx.stroke();
            ctx.setLineDash([10, 10]); ctx.lineDashOffset = -time; ctx.stroke(); ctx.setLineDash([]);

            // 4. Detector
            const detX = width * 0.8;
            ctx.fillStyle = "#333";
            ctx.fillRect(detX, centerY - 30, 20, 60);
            
            // Detector Active Light (Blinking)
            ctx.beginPath(); ctx.arc(detX + 10, centerY, 5, 0, Math.PI*2);
            const blink = Math.sin(time * 0.2) > 0 ? PALETTE.accent_green_bright : "#333";
            ctx.fillStyle = "red"; ctx.fill(); // Always on or blink? Let's make it glow based on time
            ctx.shadowBlur = 10; ctx.shadowColor = "red"; ctx.fill(); ctx.shadowBlur = 0;

            ctx.fillStyle = PALETTE.textWhite; ctx.fillText("Detector", detX + 10, centerY + 50);

            time+=2;
            anims.expSetup = requestAnimationFrame(animate);
        }
        animate();
    }

    /* --- DRAWING: STATIC BANDS --- */
    function drawStaticBands() {
        const canvas = document.getElementById("staticBandsCanvas");
        const ctx = canvas.getContext("2d");
        const container = canvas.parentElement;
        canvas.width = container.clientWidth; canvas.height = container.clientHeight;
        const centerX = canvas.width/2; const vbY = canvas.height * 0.7; const cbY = canvas.height * 0.3;
        ctx.clearRect(0,0,canvas.width,canvas.height);
        
        ctx.beginPath(); ctx.strokeStyle = PALETTE.accent; ctx.lineWidth = 3;
        for (let k = -400; k <= 400; k++) {
            const x = centerX + k; const y = cbY + (k*k)/3000;
            if (k === -400) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.beginPath();
        for (let k = -400; k <= 400; k++) {
            const x = centerX + k; const y = vbY - (k*k)/3000;
            if (k === -400) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.beginPath(); ctx.arc(centerX, vbY-10, 10, 0, Math.PI*2); ctx.fillStyle = PALETTE.textWhite; ctx.fill();
        ctx.setLineDash([6,4]); ctx.beginPath(); ctx.arc(centerX, cbY+10, 10, 0, Math.PI*2); ctx.strokeStyle = "rgba(255,255,255,0.5)"; ctx.stroke(); ctx.setLineDash([]);
        ctx.beginPath(); ctx.moveTo(centerX, vbY-25); ctx.lineTo(centerX, cbY+25); ctx.strokeStyle = PALETTE.photon; ctx.lineWidth = 2; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(centerX, cbY+25); ctx.lineTo(centerX-5, cbY+35); ctx.lineTo(centerX+5, cbY+35); ctx.fillStyle = PALETTE.photon; ctx.fill();
        ctx.fillStyle = PALETTE.textSecondary; ctx.font="bold 20px Urbanist"; 
        ctx.fillText("Banda de Conducción", centerX+150, cbY); ctx.fillText("Banda de Valencia", centerX+150, vbY);
    }

    /* --- ANIMATION 1: MB vs DFT --- */
    function initMbDftAnim() {
        const canvas = document.getElementById('mbDftCanvas');
        const ctx = canvas.getContext('2d');
        const container = canvas.parentElement;
        const electronsLeft = []; const electronsRight = [];
        for(let i=0; i<7; i++) {
            const e = { x: Math.random()*100, y: Math.random()*100, vx: (Math.random()-0.5)*1.5, vy: (Math.random()-0.5)*1.5 };
            electronsLeft.push({...e}); electronsRight.push({...e});
        }
        function updatePos(e, width, height, offsetX) {
            e.x += e.vx; e.y += e.vy;
            const left = offsetX - width*0.175; const right = offsetX + width*0.175; 
            const top = height*0.15; const bottom = height*0.85;
            if(e.x < left || e.x > right) e.vx *= -1; if(e.y < top || e.y > bottom) e.vy *= -1;
            e.x = Math.max(left, Math.min(right, e.x)); e.y = Math.max(top, Math.min(bottom, e.y));
        }
        function animate() {
            if (canvas.width !== container.clientWidth || canvas.height !== container.clientHeight) { canvas.width = container.clientWidth; canvas.height = container.clientHeight; }
            const w = canvas.width; const h = canvas.height; const cxL = w * 0.25; const cxR = w * 0.75;
            if(electronsLeft[0].x === 0 || electronsLeft[0].x > w) { electronsLeft.forEach(e => {e.x=cxL; e.y=h/2}); electronsRight.forEach(e => {e.x=cxR; e.y=h/2}); }
            ctx.clearRect(0, 0, w, h);
            
            electronsLeft.forEach(e => updatePos(e, w, h, cxL));
            ctx.beginPath(); ctx.strokeStyle = PALETTE.interaction; ctx.lineWidth = 2;
            for(let i=0; i<electronsLeft.length; i++) {
                for(let j=i+1; j<electronsLeft.length; j++) {
                    const dist = Math.sqrt(Math.pow(electronsLeft[i].x - electronsLeft[j].x, 2) + Math.pow(electronsLeft[i].y - electronsLeft[j].y, 2));
                    if(dist < 80) { ctx.moveTo(electronsLeft[i].x, electronsLeft[i].y); ctx.lineTo(electronsLeft[j].x, electronsLeft[j].y); }
                }
            }
            ctx.stroke();
            electronsLeft.forEach(e => { ctx.beginPath(); ctx.arc(e.x, e.y, 6, 0, Math.PI*2); ctx.fillStyle = PALETTE.electron; ctx.fill(); });
            ctx.fillStyle = PALETTE.textSecondary; ctx.textAlign = "center"; ctx.font = "20px Urbanist"; ctx.fillText("Sistema Interactuante", cxL, h - 30);
            
            electronsRight.forEach(e => updatePos(e, w, h, cxR));
            electronsRight.forEach(e => { ctx.beginPath(); ctx.arc(e.x, e.y, 6, 0, Math.PI*2); ctx.fillStyle = PALETTE.electron; ctx.fill(); });
            ctx.fillText("Sistema Kohn-Sham", cxR, h - 30);
            anims.mbDft = requestAnimationFrame(animate);
        }
        animate();
    }

    /* --- NEW: GREEN'S FUNCTION ANIMATION (Slide 2.5) --- */
    function initGreensAnim() {
        const cE = document.getElementById('greenElectronCanvas');
        const cH = document.getElementById('greenHoleCanvas');
        const ctxE = cE.getContext('2d');
        const ctxH = cH.getContext('2d');
        const contE = cE.parentElement;
        const contH = cH.parentElement;

        let w, h;
        let time = 0;

        function animate() {
            if (cE.width !== contE.clientWidth) { 
                cE.width = contE.clientWidth; cE.height = contE.clientHeight;
                cH.width = contH.clientWidth; cH.height = contH.clientHeight;
            }
            w = cE.width; h = cE.height;
            const yCenter = h/2;

            // Clear
            ctxE.clearRect(0,0,w,h); ctxH.clearRect(0,0,w,h);

            // Time Axis
            [ctxE, ctxH].forEach(ctx => {
                ctx.beginPath(); ctx.moveTo(20, yCenter); ctx.lineTo(w-20, yCenter);
                ctx.strokeStyle = "rgba(255,255,255,0.2)"; ctx.lineWidth=2; ctx.stroke();
                // Arrow
                ctx.beginPath(); ctx.moveTo(w-25, yCenter-5); ctx.lineTo(w-20, yCenter); ctx.lineTo(w-25, yCenter+5); ctx.stroke();
            });

            // Cycle: 0 to 180 (Slow cycle)
            const loop = time % 180;
            const startX = 40; 
            const endX = w - 40;
            const progress = (loop - 20) / 100; // Active from 20 to 120

            // --- ELECTRON (Moves Left -> Right) ---
            if (loop >= 20 && loop <= 120) {
                const x = startX + (endX - startX) * progress;
                const y = yCenter + Math.sin(progress * 15) * 10; // Quantum wiggle
                
                // Draw Path
                ctxE.beginPath(); ctxE.moveTo(startX, yCenter);
                // Draw trail logic simplified
                ctxE.lineTo(x, y); 
                ctxE.strokeStyle = PALETTE.electron; ctxE.setLineDash([5,5]); ctxE.stroke(); ctxE.setLineDash([]);

                // Draw Particle
                ctxE.beginPath(); ctxE.arc(x, y, 8, 0, Math.PI*2);
                ctxE.fillStyle = PALETTE.electron; ctxE.fill();
                ctxE.shadowBlur = 10; ctxE.shadowColor = PALETTE.electron;
            }
            // Flash Creation
            if (loop >= 15 && loop < 25) {
                ctxE.beginPath(); ctxE.arc(startX, yCenter, (loop-15)*3, 0, Math.PI*2);
                ctxE.strokeStyle = "white"; ctxE.lineWidth=2; ctxE.stroke();
            }
            // Pop Annihilation
            if (loop >= 120 && loop < 140) {
                ctxE.beginPath(); ctxE.arc(endX, yCenter, (loop-120)*4, 0, Math.PI*2);
                ctxE.strokeStyle = PALETTE.electron; ctxE.lineWidth=2; ctxE.stroke();
            }
            ctxE.shadowBlur = 0;

            // --- HOLE (Moves Right -> Left visually, representing backward time) ---
            if (loop >= 20 && loop <= 120) {
                const x = endX - (endX - startX) * progress;
                const y = yCenter + Math.cos(progress * 15) * 10; 
                
                // Draw Path
                ctxH.beginPath(); ctxH.moveTo(endX, yCenter);
                ctxH.lineTo(x, y); 
                ctxH.strokeStyle = PALETTE.purple; ctxH.setLineDash([5,5]); ctxH.stroke(); ctxH.setLineDash([]);

                // Draw Particle (Hole)
                ctxH.beginPath(); ctxH.arc(x, y, 8, 0, Math.PI*2);
                ctxH.fillStyle = PALETTE.purple; ctxH.fill();
                ctxH.shadowBlur = 10; ctxH.shadowColor = PALETTE.purple;
            }
            // Flash Creation (At EndX because it's backward time)
            if (loop >= 15 && loop < 25) {
                ctxH.beginPath(); ctxH.arc(endX, yCenter, (loop-15)*3, 0, Math.PI*2);
                ctxH.strokeStyle = "white"; ctxH.lineWidth=2; ctxH.stroke();
            }
            // Pop Annihilation
            if (loop >= 120 && loop < 140) {
                ctxH.beginPath(); ctxH.arc(startX, yCenter, (loop-120)*4, 0, Math.PI*2);
                ctxH.strokeStyle = PALETTE.purple; ctxH.lineWidth=2; ctxH.stroke();
            }
            ctxH.shadowBlur = 0;

            time++;
            anims.greenE = requestAnimationFrame(animate);
        }
        animate();
    }

    /* --- ANIMATION 2: SCREENING (Fixed Listeners) --- */
    function initScreeningBox(canvasId, type) {
        const canvas = document.getElementById(canvasId);
        const ctx = canvas.getContext('2d');
        const container = canvas.parentElement;
        
        const ions = []; const electrons = [];
        const rows = 5; const cols = 15; const spacing = 40; 

        function initGrid() {
            canvas.width = container.clientWidth; canvas.height = container.clientHeight;
            ions.length = 0; electrons.length = 0;
            const startX = (canvas.width - (cols-1)*spacing)/2;
            const startY = (canvas.height - (rows-1)*spacing)/2;
            for(let r=0; r<rows; r++) {
                for(let c=0; c<cols; c++) {
                    const x = startX + c * spacing; const y = startY + r * spacing;
                    ions.push({x, y});
                    electrons.push({ originX: x, originY: y, x: x, y: y, vx: 0, vy: 0 });
                }
            }
        }
        initGrid();

        function animate() {
            ctx.clearRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = PALETTE.ion;
            ions.forEach(ion => { ctx.beginPath(); ctx.arc(ion.x, ion.y, 4, 0, Math.PI*2); ctx.fill(); });

            ctx.fillStyle = PALETTE.bgElectron;
            const targetMouse = type === 'electron' ? screeningMouse.e : screeningMouse.h;

            electrons.forEach(e => {
                const k = 0.05;
                let fx = (e.originX - e.x) * k; let fy = (e.originY - e.y) * k;
                const dx = e.x - targetMouse.x; const dy = e.y - targetMouse.y;
                const distSq = dx*dx + dy*dy; const dist = Math.sqrt(distSq);
                
                if (dist < 200) {
                    const forceMag = 1500 / (distSq + 100);
                    if (type === 'electron') { fx += (dx/dist) * forceMag; fy += (dy/dist) * forceMag; } 
                    else { fx -= (dx/dist) * forceMag; fy -= (dy/dist) * forceMag; }
                }
                e.vx = (e.vx + fx) * 0.85; e.vy = (e.vy + fy) * 0.85;
                e.x += e.vx; e.y += e.vy;
                ctx.beginPath(); ctx.arc(e.x, e.y, 3, 0, Math.PI*2); ctx.fill();
            });

            if (targetMouse.x > 0) {
                ctx.beginPath(); ctx.arc(targetMouse.x, targetMouse.y, 8, 0, Math.PI*2);
                if (type === 'electron') { ctx.fillStyle = PALETTE.electron; ctx.shadowColor = PALETTE.electron; } 
                else { ctx.fillStyle = PALETTE.ion; ctx.shadowColor = PALETTE.ion; }
                ctx.shadowBlur = 20; ctx.fill(); ctx.shadowBlur = 0; 
            }

            if (type === 'electron') anims.screenE = requestAnimationFrame(animate);
            else anims.screenH = requestAnimationFrame(animate);
        }
        animate();
    }

    /* --- ANIMATION 3: EXCITATION --- */
    const exCanvas = document.getElementById('excitationCanvas');
    const exCtx = exCanvas.getContext('2d');
    let exW, exH, exTime=0, phase='incoming', photonX=-100, electronY=0, electronX=0;
    const bands = { vbTop: 0, cbBottom: 0, centerX: 0 };

    function resizeExcitation() {
        const wrapper = exCanvas.parentElement;
        if(!wrapper) return;
        exW = exCanvas.width = wrapper.clientWidth; exH = exCanvas.height = wrapper.clientHeight;
        bands.vbTop = exH * 0.7; bands.cbBottom = exH * 0.3; bands.centerX = exW / 2;
        if (phase === 'incoming') { electronY = bands.vbTop; electronX = bands.centerX; }
        animateExcitation();
    }

    function drawParabolicBands() {
        exCtx.strokeStyle = PALETTE.accent; exCtx.lineWidth = 3;
        const kMax = 400;
        exCtx.beginPath();
        for (let k = -kMax; k <= kMax; k++) {
            const x = bands.centerX + k; const y = bands.cbBottom + (k*k)/2500;
            if (k === -kMax) exCtx.moveTo(x, y); else exCtx.lineTo(x, y);
        }
        exCtx.stroke();
        exCtx.beginPath();
        for (let k = -kMax; k <= kMax; k++) {
            const x = bands.centerX + k; const y = bands.vbTop - (k*k)/2500;
            if (k === -kMax) exCtx.moveTo(x, y); else exCtx.lineTo(x, y);
        }
        exCtx.stroke();
    }

    function drawPhoton(x, y) {
        exCtx.beginPath(); exCtx.strokeStyle = PALETTE.photon; exCtx.lineWidth = 3;
        for (let i = 0; i < 80; i++) {
            const px = x - i; const py = y + Math.sin((x - i) * 0.2 - exTime * 0.2) * 8;
            if (i === 0) exCtx.moveTo(px, py); else exCtx.lineTo(px, py);
        }
        exCtx.stroke(); exCtx.fillStyle = PALETTE.photon; exCtx.beginPath();
        exCtx.arc(x, y + Math.sin(x * 0.2 - exTime * 0.2) * 8, 3, 0, Math.PI*2); exCtx.fill();
    }

    function drawElectron(x, y) {
        const grad = exCtx.createRadialGradient(x, y, 2, x, y, 15);
        grad.addColorStop(0, '#ffffff'); grad.addColorStop(0.4, PALETTE.accent); grad.addColorStop(1, 'rgba(222, 255, 154, 0)');
        exCtx.fillStyle = grad; exCtx.beginPath(); exCtx.arc(x, y, 15, 0, Math.PI*2); exCtx.fill();
        exCtx.fillStyle = '#fff'; exCtx.beginPath(); exCtx.arc(x, y, 4, 0, Math.PI*2); exCtx.fill();
    }

    function drawHole(x, y) {
        exCtx.strokeStyle = PALETTE.accent; exCtx.lineWidth = 2;
        exCtx.beginPath(); exCtx.arc(x, y, 8, 0, Math.PI*2); exCtx.stroke();
        exCtx.fillStyle = 'rgba(222, 255, 154, 0.1)'; exCtx.fill();
        exCtx.beginPath(); exCtx.moveTo(x-4, y); exCtx.lineTo(x+4, y); exCtx.moveTo(x, y-4); exCtx.lineTo(x, y+4); exCtx.stroke();
    }

    function drawInteraction(ex, ey, hx, hy) {
        exCtx.setLineDash([5, 5]); exCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        exCtx.beginPath(); exCtx.moveTo(ex, ey); exCtx.lineTo(hx, hy); exCtx.stroke(); exCtx.setLineDash([]);
    }

    function animateExcitation() {
        exCtx.clearRect(0, 0, exW, exH); drawParabolicBands();
        const targetY = bands.cbBottom + 20; const startY = bands.vbTop - 10;
        if (phase === 'incoming') {
            drawElectron(electronX, startY); photonX += 6; drawPhoton(photonX, startY);
            if (photonX >= electronX) phase = 'transition';
        } else if (phase === 'transition') {
            drawHole(electronX, startY); const speed = (electronY - targetY) * 0.08;
            electronY -= Math.max(speed, 1.0); drawElectron(electronX, electronY);
            if (electronY <= targetY) { electronY = targetY; phase = 'bound'; }
        } else if (phase === 'bound') {
            drawHole(electronX, startY); drawElectron(electronX, targetY + Math.sin(exTime*0.05)*3);
            drawInteraction(electronX, targetY, electronX, startY);
            exCtx.fillStyle = PALETTE.accent; exCtx.font = 'bold 20px Urbanist'; exCtx.textAlign = 'center';
            exCtx.fillText("Bound Exciton", bands.centerX + 100, exH/2 ); exCtx.textAlign = 'left';
        }
        exTime++; anims.excitation = requestAnimationFrame(animateExcitation);
    }

    function resetAnim() {
        if(anims.excitation) cancelAnimationFrame(anims.excitation); 
        phase = 'incoming'; photonX = -100; resizeExcitation();
    }

    window.addEventListener('resize', () => {
        if(currentSlide === 1) initMbDftAnim();
        if(currentSlide === 2) initGreensAnim(); 
        if(currentSlide === 4) resizeExcitation();
    });
    window.addEventListener('load', () => { updateProgress(); });
</script>

</body>
</html>